#!/usr/bin/env bash
set -euo pipefail

LOG="${GH_MOCK_LOG:-/tmp/gh_mock_calls.log}"
STATE_DIR="${GH_MOCK_STATE_DIR:-/tmp/gh_mock_state}"
TRACE_JSON="${GH_MOCK_TRACE_JSON:-/tmp/gh_mock_trace.jsonl}"
mkdir -p "$STATE_DIR"

echo "[MOCK GH] $*" >> "$LOG"

# Log to trace file in JSON format
_trace_json() {
  local cmd="$1"
  local args="$2"
  local response="$3"
  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")

  # Safely escape JSON strings
  args=$(echo "$args" | sed 's/\\/\\\\/g; s/"/\\"/g; s/$/\\n/g' | tr -d '\n')
  response=$(echo "$response" | sed 's/\\/\\\\/g; s/"/\\"/g; s/$/\\n/g' | tr -d '\n')

  echo "{\"timestamp\":\"$timestamp\",\"command\":\"$cmd\",\"args\":\"$args\",\"response\":\"$response\"}" >> "$TRACE_JSON"
}

# Scenario controls (set via env in the harness)
PR_EXISTS="${MOCK_PR_EXISTS:-false}"           # if true, pr list returns an existing PR number
PR_NUMBER="${MOCK_PR_NUMBER:-123}"
PR_URL="${MOCK_PR_URL:-https://mock/pr/123}"

# Simulate mergeability "UNKNOWN" for first N calls to `pr view --json mergeable`
UNSTABLE_CALLS="${MOCK_UNSTABLE_CALLS:-0}"
MERGEABLE_OK="${MOCK_MERGEABLE_OK:-MERGEABLE}" # MERGEABLE / CONFLICTING / etc.

# Status checks simulation: SUCCESS / FAILURE / PENDING
CHECKS_STATUS="${MOCK_CHECKS_STATUS:-SUCCESS}"

# Auto-merge command can be forced to fail
MERGE_ENABLE_FAIL="${MOCK_ENABLE_AUTOMERGE_FAIL:-false}"

# PR merged state (used by polling)
# We simulate that the PR becomes merged after N polls (default 1)
MERGE_AFTER_POLLS="${MOCK_MERGE_AFTER_POLLS:-1}"

poll_count_file="$STATE_DIR/poll_count"
mergeable_calls_file="$STATE_DIR/mergeable_calls"

poll_count="$(cat "$poll_count_file" 2>/dev/null || echo "0")"
mergeable_calls="$(cat "$mergeable_calls_file" 2>/dev/null || echo "0")"

# Helpers
has_arg() { for a in "$@"; do [[ "$a" == "$1" ]] && return 0; done; return 1; }
arg_after() {
  local key="$1"; shift
  while [[ $# -gt 0 ]]; do
    if [[ "$1" == "$key" ]]; then
      shift
      echo "${1:-}"
      return 0
    fi
    shift
  done
  echo ""
}

cmd="${1:-}"
sub="${2:-}"

# Consolidate exit logic to ensure consistent handling
exit_with_code() {
  local code="$1"
  _trace_json "$2" "$3" "$4"
  exit "$code"
}

if [[ "$cmd" == "pr" && "$sub" == "list" ]]; then
  # Supports: gh pr list --head X --base Y --json number --jq '.[0].number'
  jq_expr="$(arg_after --jq "$@")"
  response=""
  if [[ "$PR_EXISTS" == "true" ]]; then
    if [[ -n "$jq_expr" ]]; then
      response="$PR_NUMBER"
      echo "$PR_NUMBER"
    else
      response="[{\"number\":$PR_NUMBER}]"
      echo "[{\"number\":$PR_NUMBER}]"
    fi
  else
    # no PR found
    if [[ -n "$jq_expr" ]]; then
      response=""
      echo ""
    else
      response="[]"
      echo "[]"
    fi
  fi
  exit_with_code 0 "pr list" "$*" "$response"
fi

if [[ "$cmd" == "pr" && "$sub" == "create" ]]; then
  # Returns URL
  exit_with_code 0 "pr create" "$*" "$PR_URL"
fi

if [[ "$cmd" == "pr" && "$sub" == "edit" ]]; then
  # label add etc
  exit_with_code 0 "pr edit" "$*" "OK"
fi

if [[ "$cmd" == "pr" && "$sub" == "merge" ]]; then
  # The script uses: gh pr merge "$PR_NUMBER" --auto --merge
  if [[ "$MERGE_ENABLE_FAIL" == "true" ]]; then
    exit_with_code 1 "pr merge" "$*" "ERROR: Pull request is in unstable status"
  fi
  exit_with_code 0 "pr merge" "$*" "OK"
fi

if [[ "$cmd" == "pr" && "$sub" == "view" ]]; then
  # Many shapes:
  # - gh pr view URL --json number --jq '.number'
  # - gh pr view PR --json url --jq '.url'
  # - gh pr view PR --json merged --jq '.merged'
  # - gh pr view PR --json closed --jq '.closed'
  # - gh pr view PR --json mergeable --jq '.mergeable'
  # - gh pr view PR --json statusCheckRollup --jq '...complex...'
  json_fields="$(arg_after --json "$@")"
  jq_expr="$(arg_after --jq "$@")"

  # Polling merged/closed changes over time
  # merged becomes true after MERGE_AFTER_POLLS loops
  poll_count=$((poll_count + 1))
  echo "$poll_count" > "$poll_count_file"

  merged="false"
  closed="false"
  if [[ "$poll_count" -ge "$MERGE_AFTER_POLLS" ]]; then
    merged="true"
    closed="true"
  fi

  # mergeable: return UNKNOWN first N calls when requesting mergeable
  if echo "$json_fields" | grep -q "mergeable"; then
    mergeable_calls=$((mergeable_calls + 1))
    echo "$mergeable_calls" > "$mergeable_calls_file"
    if [[ "$mergeable_calls" -le "$UNSTABLE_CALLS" ]]; then
      mergeable="UNKNOWN"
    else
      mergeable="$MERGEABLE_OK"
    fi
  else
    mergeable="$MERGEABLE_OK"
  fi

  # If they provided --jq, output only the requested scalar-like value.
  response=""
  if [[ -n "$jq_expr" ]]; then
    case "$jq_expr" in
      ".number") response="$PR_NUMBER"; echo "$PR_NUMBER" ;;
      ".url") response="$PR_URL"; echo "$PR_URL" ;;
      ".merged") response="$merged"; echo "$merged" ;;
      ".closed") response="$closed"; echo "$closed" ;;
      ".mergeable"*) response="$mergeable"; echo "$mergeable" ;;
      *statusCheckRollup* ) response="$CHECKS_STATUS"; echo "$CHECKS_STATUS" ;;
      *) response=""; echo "" ;;
    esac
    _trace_json "pr view" "$*" "$response"
    exit 0
  fi

  # Else output minimal JSON
  # (rare in your script because you always pass --jq)
  response="{\"number\":$PR_NUMBER,\"url\":\"$PR_URL\",\"merged\":$merged,\"closed\":$closed,\"mergeable\":\"$mergeable\"}"
  echo "$response"
  _trace_json "pr view" "$*" "$response"
  exit 0
fi

echo "MOCK GH: unsupported command: $*" >&2
exit 2
