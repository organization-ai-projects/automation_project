#!/usr/bin/env bash
# Git hook: commit-msg
# Validates commit message format
# Bypass: SKIP_COMMIT_VALIDATION=1 git commit ...
set -euo pipefail

COMMIT_MSG_FILE="$1"
ROOT_DIR="$(git rev-parse --show-toplevel)"

if [[ -z "${COMMIT_MSG_FILE:-}" || ! -f "$COMMIT_MSG_FILE" ]]; then
  echo "❌ commit-msg hook: missing or invalid commit message file" >&2
  exit 1
fi

# Only validate the commit subject line; body/footer are handled separately.
COMMIT_SUBJECT=$(head -n1 "$COMMIT_MSG_FILE")

# Allow bypass for emergency situations
if [[ "${SKIP_COMMIT_VALIDATION:-}" == "1" ]]; then
  exit 0
fi

# shellcheck source=scripts/common_lib/versioning/file_versioning/git/commit_format.sh
source "$ROOT_DIR/scripts/common_lib/versioning/file_versioning/git/commit_format.sh"

extract_scopes_from_commit_message() {
  local message="$1"
  local scope_re='^[a-z]+\(([^)]+)\):'
  local scope
  if [[ ! "$message" =~ $scope_re ]]; then
    return 0
  fi
  IFS=',' read -r -a scopes <<< "${BASH_REMATCH[1]}"
  for scope in "${scopes[@]}"; do
    # Trim leading/trailing spaces to support "scope1, scope2" syntax.
    scope="${scope#"${scope%%[![:space:]]*}"}"
    scope="${scope%"${scope##*[![:space:]]}"}"
    [[ -n "$scope" ]] && printf '%s\n' "$scope"
  done
}

detect_required_scopes_from_staged_files() {
  local files
  files=$(git diff --cached --name-only)
  local required=()

  while IFS= read -r file; do
    [[ -z "$file" ]] && continue

    if [[ "$file" =~ ^projects/libraries/([^/]+)/ ]]; then
      local scope="projects/libraries/${BASH_REMATCH[1]}"
      if [[ ! " ${required[*]} " =~ " ${scope} " ]]; then
        required+=("$scope")
      fi
      continue
    fi

    if [[ "$file" =~ ^projects/products/[^/]+/([^/]+)/ ]]; then
      local product_name="${BASH_REMATCH[1]}"
      local component=""
      if [[ "$file" =~ ^projects/products/[^/]+/[^/]+/(ui|backend)/ ]]; then
        component="${BASH_REMATCH[1]}"
      fi

      local scope="projects/products/${product_name}"
      if [[ -n "$component" ]]; then
        scope="${scope}/${component}"
      fi

      if [[ ! " ${required[*]} " =~ " ${scope} " ]]; then
        required+=("$scope")
      fi
    fi
  done <<< "$files"

  printf '%s\n' "${required[@]}"
}

validate_and_normalize_issue_refs_footer() {
  local issue_ref_re='(^|[[:space:]])(closes|fixes|resolves|part[[:space:]]+of|related[[:space:]]+to)[[:space:]]+#[0-9]+([[:space:]]|$)'
  local trailer_line_re='^[[:space:]]*(Closes|Fixes|Resolves|Part[[:space:]]+of|Related[[:space:]]+to)[[:space:]]+#[0-9]+[[:space:]]*$'
  local subject_lower
  subject_lower="$(printf '%s' "$COMMIT_SUBJECT" | tr '[:upper:]' '[:lower:]')"

  if [[ "$subject_lower" =~ $issue_ref_re ]]; then
    echo "❌ Issue references must be in commit footer, not in subject." >&2
    echo "   Move 'Closes/Fixes/Resolves/Part of/Related to #...' to footer lines." >&2
    return 1
  fi

  # Collect action trailers from non-comment lines (excluding subject line).
  mapfile -t all_action_trailers < <(
    sed '/^[[:space:]]*#/d' "$COMMIT_MSG_FILE" \
      | tail -n +2 \
      | sed -nE 's/^[[:space:]]*((Closes|Fixes|Resolves|Part[[:space:]]+of|Related[[:space:]]+to)[[:space:]]+#[0-9]+)[[:space:]]*$/\1/p' \
      | awk '!seen[$0]++'
  )

  [[ ${#all_action_trailers[@]} -eq 0 ]] && return 0

  mapfile -t message_lines < <(sed '/^[[:space:]]*#/d' "$COMMIT_MSG_FILE")

  local last_non_empty=-1
  local i line

  for i in "${!message_lines[@]}"; do
    line="${message_lines[$i]}"
    if [[ "$line" =~ [^[:space:]] ]]; then
      last_non_empty=$i
    fi
  done

  declare -A footer_trailers=()
  if (( last_non_empty > 0 )); then
    # A footer is treated as the trailing block of trailer lines at the end
    # of the message (excluding subject and comments).
    i=$last_non_empty
    while (( i > 0 )); do
      line="${message_lines[$i]}"
      if [[ "$line" =~ ^[[:space:]]*$ ]]; then
        i=$((i - 1))
        continue
      fi
      if [[ "$line" =~ $trailer_line_re ]]; then
        line="$(echo "$line" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
        footer_trailers["$line"]=1
        i=$((i - 1))
        continue
      fi
      break
    done
  fi

  local -a missing_trailers=()
  for line in "${all_action_trailers[@]}"; do
    line="$(echo "$line" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
    if [[ -z "${footer_trailers[$line]:-}" ]]; then
      missing_trailers+=("$line")
    fi
  done

  [[ ${#missing_trailers[@]} -eq 0 ]] && return 0

  # Ensure a footer separator before appending missing trailers.
  if [[ -s "$COMMIT_MSG_FILE" ]]; then
    if ! tail -n1 "$COMMIT_MSG_FILE" | grep -qE '^[[:space:]]*$'; then
      echo >> "$COMMIT_MSG_FILE"
    fi
  fi
  echo >> "$COMMIT_MSG_FILE"

  for line in "${missing_trailers[@]}"; do
    echo "$line" >> "$COMMIT_MSG_FILE"
  done

  return 0
}

# Validate format: <type>(<scope>): <message> or <type>: <message>
# Allows multiple scopes separated by commas and dot-scopes: feat(ci,.github): message
if ! validate_commit_message_format "$COMMIT_SUBJECT" '[[:space:]]' true; then
  echo "❌ Invalid commit message format!" >&2
  echo "" >&2
  echo "Expected format:" >&2
  echo "  <type>(<scope>): <message>" >&2
  echo "  or" >&2
  echo "  <type>: <message>" >&2
  echo "" >&2
  echo "Allowed types:" >&2
  echo "  feature, feat, fix, fixture, doc, docs, refactor, test, tests, chore" >&2
  echo "" >&2
  echo "Examples:" >&2
  echo "  feat(projects/libraries/security): add user authentication" >&2
  echo "  feat(ci,scripts): add workflows and sync script" >&2
  echo "  docs(.github): add default PR template" >&2
  echo "  fix: resolve null pointer exception" >&2
  echo "  docs(readme): update installation instructions" >&2
  echo "  refactor(projects/products/accounts/backend): improve audit flush handling" >&2
  echo "" >&2
  echo "Your commit message:" >&2
  echo "  $COMMIT_SUBJECT" >&2
  echo "" >&2
  echo "Bypass (emergency only): SKIP_COMMIT_VALIDATION=1 git commit ..." >&2
  exit 1
fi

if ! validate_and_normalize_issue_refs_footer; then
  exit 1
fi

required_scopes=$(detect_required_scopes_from_staged_files)
if [[ -n "$required_scopes" ]]; then
  commit_scopes=$(extract_scopes_from_commit_message "$COMMIT_SUBJECT")

  if [[ -z "$commit_scopes" ]]; then
    echo "❌ Missing required scope in commit message." >&2
    echo "" >&2
    echo "Detected changed files requiring scope:" >&2
    while IFS= read -r scope; do
      [[ -n "$scope" ]] && echo "  - $scope" >&2
    done <<< "$required_scopes"
    echo "" >&2
    echo "Expected format example:" >&2
    echo "  fix(projects/libraries/<library_name>): ..." >&2
    echo "  fix(projects/products/<product_name>): ..." >&2
    echo "  fix(projects/products/<product_name>/backend): ..." >&2
    exit 1
  fi

  missing_scopes=()
  while IFS= read -r required_scope; do
    [[ -z "$required_scope" ]] && continue
    if ! grep -Fxq "$required_scope" <<< "$commit_scopes"; then
      missing_scopes+=("$required_scope")
    fi
  done <<< "$required_scopes"

  if [[ "${#missing_scopes[@]}" -gt 0 ]]; then
    echo "❌ Commit scope does not match touched files." >&2
    echo "" >&2
    echo "Missing required scope(s):" >&2
    for scope in "${missing_scopes[@]}"; do
      echo "  - $scope" >&2
    done
    echo "" >&2
    echo "Commit scopes found:" >&2
    while IFS= read -r scope; do
      [[ -n "$scope" ]] && echo "  - $scope" >&2
    done <<< "$commit_scopes"
    exit 1
  fi
fi

exit 0
