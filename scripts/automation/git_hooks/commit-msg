#!/usr/bin/env bash
# Git hook: commit-msg
# Validates commit message format
# Bypass: SKIP_COMMIT_VALIDATION=1 git commit ...
set -euo pipefail

COMMIT_MSG_FILE="$1"
ROOT_DIR="$(git rev-parse --show-toplevel)"

if [[ -z "${COMMIT_MSG_FILE:-}" || ! -f "$COMMIT_MSG_FILE" ]]; then
  echo "❌ commit-msg hook: missing or invalid commit message file" >&2
  exit 1
fi

# Only validate the commit subject line; body/footer are handled separately.
COMMIT_SUBJECT=$(head -n1 "$COMMIT_MSG_FILE")

# Allow bypass for emergency situations
if [[ "${SKIP_COMMIT_VALIDATION:-}" == "1" ]]; then
  exit 0
fi

# shellcheck source=scripts/common_lib/versioning/file_versioning/git/commit_format.sh
source "$ROOT_DIR/scripts/common_lib/versioning/file_versioning/git/commit_format.sh"

extract_scopes_from_commit_message() {
  local message="$1"
  local scope_re='^[a-z]+\(([^)]+)\):'
  local scope
  if [[ ! "$message" =~ $scope_re ]]; then
    return 0
  fi
  IFS=',' read -r -a scopes <<< "${BASH_REMATCH[1]}"
  for scope in "${scopes[@]}"; do
    # Trim leading/trailing spaces to support "scope1, scope2" syntax.
    scope="${scope#"${scope%%[![:space:]]*}"}"
    scope="${scope%"${scope##*[![:space:]]}"}"
    [[ -n "$scope" ]] && printf '%s\n' "$scope"
  done
}

detect_required_scopes_from_staged_files() {
  local files
  files=$(git diff --cached --name-only)
  local required=()

  while IFS= read -r file; do
    [[ -z "$file" ]] && continue

    if [[ "$file" =~ ^projects/libraries/([^/]+)/ ]]; then
      local scope="projects/libraries/${BASH_REMATCH[1]}"
      if [[ ! " ${required[*]} " =~ " ${scope} " ]]; then
        required+=("$scope")
      fi
      continue
    fi

    if [[ "$file" =~ ^projects/products/[^/]+/([^/]+)/ ]]; then
      local product_name="${BASH_REMATCH[1]}"
      local component=""
      if [[ "$file" =~ ^projects/products/[^/]+/[^/]+/(ui|backend)/ ]]; then
        component="${BASH_REMATCH[1]}"
      fi

      local scope="projects/products/${product_name}"
      if [[ -n "$component" ]]; then
        scope="${scope}/${component}"
      fi

      if [[ ! " ${required[*]} " =~ " ${scope} " ]]; then
        required+=("$scope")
      fi
    fi
  done <<< "$files"

  printf '%s\n' "${required[@]}"
}

validate_and_normalize_issue_refs_footer() {
  local issue_ref_re='(^|[[:space:]])(closes|fixes|resolves|part[[:space:]]+of|related[[:space:]]+to)[[:space:]]+#[0-9]+([[:space:]]|$)'
  local trailer_line_re='^[[:space:]]*(Closes|Fixes|Resolves|Part[[:space:]]+of|Related[[:space:]]+to)[[:space:]]+#[0-9]+[[:space:]]*$'
  local subject_lower
  subject_lower="$(printf '%s' "$COMMIT_SUBJECT" | tr '[:upper:]' '[:lower:]')"

  if [[ "$subject_lower" =~ $issue_ref_re ]]; then
    echo "❌ Issue references must be in commit footer, not in subject." >&2
    echo "   Move 'Closes/Fixes/Resolves/Part of/Related to #...' to footer lines." >&2
    return 1
  fi

  mapfile -t message_lines < <(sed '/^[[:space:]]*#/d' "$COMMIT_MSG_FILE")
  [[ ${#message_lines[@]} -eq 0 ]] && return 0

  local -a trailers=()
  local -a content_lines=()
  local line normalized

  # Keep subject as-is; normalize only body/footer lines.
  content_lines+=("${message_lines[0]}")
  for line in "${message_lines[@]:1}"; do
    if [[ "$line" =~ $trailer_line_re ]]; then
      normalized="$(echo "$line" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
      if [[ ! " ${trailers[*]} " =~ " ${normalized} " ]]; then
        trailers+=("$normalized")
      fi
      continue
    fi
    content_lines+=("$line")
  done

  [[ ${#trailers[@]} -eq 0 ]] && return 0

  # Trim trailing blank lines before appending a dedicated trailer footer block.
  while [[ ${#content_lines[@]} -gt 0 ]]; do
    line="${content_lines[$((${#content_lines[@]} - 1))]}"
    [[ "$line" =~ ^[[:space:]]*$ ]] || break
    unset "content_lines[$((${#content_lines[@]} - 1))]"
  done

  # Collapse repeated blank lines in body after trailer extraction.
  local -a compact_lines=()
  local prev_blank=false
  for line in "${content_lines[@]}"; do
    if [[ "$line" =~ ^[[:space:]]*$ ]]; then
      if [[ "$prev_blank" == true ]]; then
        continue
      fi
      prev_blank=true
    else
      prev_blank=false
    fi
    compact_lines+=("$line")
  done

  {
    local i
    for i in "${!compact_lines[@]}"; do
      echo "${compact_lines[$i]}"
    done
    echo
    for line in "${trailers[@]}"; do
      echo "$line"
    done
  } > "$COMMIT_MSG_FILE"

  return 0
}

# Validate format: <type>(<scope>): <message> or <type>: <message>
# Allows multiple scopes separated by commas and dot-scopes: feat(ci,.github): message
if ! validate_commit_message_format "$COMMIT_SUBJECT" '[[:space:]]' true; then
  echo "❌ Invalid commit message format!" >&2
  echo "" >&2
  echo "Expected format:" >&2
  echo "  <type>(<scope>): <message>" >&2
  echo "  or" >&2
  echo "  <type>: <message>" >&2
  echo "" >&2
  echo "Allowed types:" >&2
  echo "  feature, feat, fix, fixture, doc, docs, refactor, test, tests, chore" >&2
  echo "" >&2
  echo "Examples:" >&2
  echo "  feat(projects/libraries/security): add user authentication" >&2
  echo "  feat(ci,scripts): add workflows and sync script" >&2
  echo "  docs(.github): add default PR template" >&2
  echo "  fix: resolve null pointer exception" >&2
  echo "  docs(readme): update installation instructions" >&2
  echo "  refactor(projects/products/accounts/backend): improve audit flush handling" >&2
  echo "" >&2
  echo "Your commit message:" >&2
  echo "  $COMMIT_SUBJECT" >&2
  echo "" >&2
  echo "Bypass (emergency only): SKIP_COMMIT_VALIDATION=1 git commit ..." >&2
  exit 1
fi

if ! validate_and_normalize_issue_refs_footer; then
  exit 1
fi

required_scopes=$(detect_required_scopes_from_staged_files)
if [[ -n "$required_scopes" ]]; then
  commit_scopes=$(extract_scopes_from_commit_message "$COMMIT_SUBJECT")

  if [[ -z "$commit_scopes" ]]; then
    echo "❌ Missing required scope in commit message." >&2
    echo "" >&2
    echo "Detected changed files requiring scope:" >&2
    while IFS= read -r scope; do
      [[ -n "$scope" ]] && echo "  - $scope" >&2
    done <<< "$required_scopes"
    echo "" >&2
    echo "Expected format example:" >&2
    echo "  fix(projects/libraries/<library_name>): ..." >&2
    echo "  fix(projects/products/<product_name>): ..." >&2
    echo "  fix(projects/products/<product_name>/backend): ..." >&2
    exit 1
  fi

  missing_scopes=()
  while IFS= read -r required_scope; do
    [[ -z "$required_scope" ]] && continue
    if ! grep -Fxq "$required_scope" <<< "$commit_scopes"; then
      missing_scopes+=("$required_scope")
    fi
  done <<< "$required_scopes"

  if [[ "${#missing_scopes[@]}" -gt 0 ]]; then
    echo "❌ Commit scope does not match touched files." >&2
    echo "" >&2
    echo "Missing required scope(s):" >&2
    for scope in "${missing_scopes[@]}"; do
      echo "  - $scope" >&2
    done
    echo "" >&2
    echo "Commit scopes found:" >&2
    while IFS= read -r scope; do
      [[ -n "$scope" ]] && echo "  - $scope" >&2
    done <<< "$commit_scopes"
    exit 1
  fi
fi

exit 0
