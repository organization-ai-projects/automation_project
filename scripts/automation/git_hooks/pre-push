#!/usr/bin/env bash
# Git hook: pre-push
# Runs scope-aware formatting, linting, and tests before push
# Bypass: SKIP_PRE_PUSH=1 git push ...
set -euo pipefail

# Allow bypass for emergency situations
if [[ "${SKIP_PRE_PUSH:-}" == "1" ]]; then
  echo "‚ö†Ô∏è  Pre-push checks skipped (SKIP_PRE_PUSH=1)"
  exit 0
fi

echo "üîç Running pre-push checks..."
echo ""

# Get the root of the git repository
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT" || exit 1
HOOKS_DIR="$REPO_ROOT/scripts/automation/git_hooks"
# shellcheck source=scripts/automation/git_hooks/lib/issue_parent_guard.sh
source "$HOOKS_DIR/lib/issue_parent_guard.sh"

# Get commit messages from commits being pushed
UPSTREAM_BRANCH="$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")"
if [[ -z "$UPSTREAM_BRANCH" ]]; then
  echo "‚ö†Ô∏è  No upstream branch detected. Falling back to origin/dev for scope detection."
  UPSTREAM_BRANCH="origin/dev"
fi

commits=$(git log "$UPSTREAM_BRANCH"..HEAD --format=%B 2>/dev/null || true)

validate_no_root_parent_issue_refs() {
  local commits_input="$1"
  local refs
  refs="$(extract_issue_refs_from_text "$commits_input" || true)"
  [[ -z "$refs" ]] && return 0

  if ! command -v gh >/dev/null 2>&1; then
    echo "‚ùå Cannot validate root parent issue references: 'gh' CLI is required."
    echo "   Install gh, or bypass in emergency: SKIP_PRE_PUSH=1 git push"
    return 1
  fi

  local repo_name
  repo_name="$(resolve_repo_name_with_owner)"
  if [[ -z "$repo_name" ]]; then
    echo "‚ùå Cannot resolve GitHub repository for footer validation."
    echo "   Ensure gh auth/network is available, or bypass in emergency: SKIP_PRE_PUSH=1 git push"
    return 1
  fi

  local parent_refs=()
  local action
  local issue_number
  while IFS='|' read -r action issue_number; do
    [[ -z "$issue_number" ]] && continue
    if issue_is_root_parent "$issue_number" "$repo_name"; then
      parent_refs+=("${action} #${issue_number}")
    fi
  done <<< "$refs"

  if [[ ${#parent_refs[@]} -gt 0 ]]; then
    echo "‚ùå Root parent issue references detected in commits being pushed:"
    printf '   - %s\n' "${parent_refs[@]}"
    echo "   Root parent refs are forbidden in commit trailers (Part of/Related to/Closes/Fixes/Resolves)."
    echo "   Reference child issues instead."
    return 1
  fi
}

validate_part_of_only_push() {
  local commits_input="$1"
  local refs
  local action
  local has_tracking=0
  local has_closing=0

  refs="$(extract_issue_refs_from_text "$commits_input" || true)"
  [[ -z "$refs" ]] && return 0

  while IFS='|' read -r action _; do
    [[ -z "$action" ]] && continue
    if [[ "$action" == "closes" || "$action" == "fixes" || "$action" == "resolves" ]]; then
      has_closing=1
    fi
    if [[ "$action" == "part of" || "$action" == "related to" ]]; then
      has_tracking=1
    fi
  done <<< "$refs"

  if [[ $has_tracking -eq 1 && $has_closing -eq 0 && "${ALLOW_PART_OF_ONLY_PUSH:-}" != "1" ]]; then
    echo "‚ùå Push blocked: commit range contains tracking refs (Part of/Related to) without any closing ref."
    echo "   This usually indicates incomplete issue lifecycle updates."
    echo "   Fix by adding proper child issue closures when done, or confirm exceptional push with:"
    echo "   ALLOW_PART_OF_ONLY_PUSH=1 git push"
    return 1
  fi
}

if ! validate_no_root_parent_issue_refs "$commits"; then
  exit 1
fi

if ! validate_part_of_only_push "$commits"; then
  exit 1
fi

compute_changed_files() {
  local upstream="$1"
  local files=""

  # Standard case: upstream tracking branch exists.
  files=$(git diff --name-only "${upstream}"..HEAD 2>/dev/null || true)
  if [[ -n "$files" ]]; then
    printf '%s\n' "$files"
    return 0
  fi

  # First push / missing upstream locally: compare from merge-base with origin/dev.
  if git rev-parse --verify --quiet origin/dev >/dev/null; then
    local base
    base=$(git merge-base origin/dev HEAD 2>/dev/null || true)
    if [[ -n "$base" ]]; then
      files=$(git diff --name-only "${base}"..HEAD 2>/dev/null || true)
      if [[ -n "$files" ]]; then
        printf '%s\n' "$files"
        return 0
      fi
    fi
  fi

  # Final fallback: changed files in the latest commit only.
  files=$(git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null || true)
  printf '%s\n' "$files"
}

changed_files=$(compute_changed_files "$UPSTREAM_BRANCH")

is_docs_or_scripts_only_change() {
  local files="$1"
  local file

  [[ -z "$files" ]] && return 1

  while IFS= read -r file; do
    [[ -z "$file" ]] && continue
    # Intentionally treat workflow-only changes as non-Rust changes for pre-push.
    # Workflow logic is validated in CI/automation workflows and review.
    if [[ "$file" =~ \.md$ ]] || [[ "$file" == documentation/* ]] || [[ "$file" == .github/documentation/* ]] || [[ "$file" == .github/ISSUE_TEMPLATE/* ]] || [[ "$file" == .github/PULL_REQUEST_TEMPLATE/* ]] || [[ "$file" == scripts/* ]] || [[ "$file" == .github/workflows/* ]]; then
      continue
    fi
    return 1
  done <<< "$files"

  return 0
}

run_shell_syntax_checks() {
  local files="$1"
  local checked=0
  local file

  while IFS= read -r file; do
    [[ -z "$file" || ! -f "$file" ]] && continue

    local is_shell=false
    if [[ "$file" == *.sh ]]; then
      is_shell=true
    elif [[ -x "$file" ]]; then
      local shebang
      shebang=$(head -n1 "$file" 2>/dev/null || true)
      if [[ "$shebang" =~ ^#!.*(ba)?sh([[:space:]]|$) ]]; then
        is_shell=true
      fi
    fi

    if [[ "$is_shell" == true ]]; then
      echo "   - bash -n $file"
      bash -n "$file"
      checked=1
    fi
  done <<< "$files"

  if [[ $checked -eq 0 ]]; then
    echo "   (no shell scripts changed)"
  fi
}

if is_docs_or_scripts_only_change "$changed_files"; then
  echo "üìÑ Docs/scripts-only changes detected."
  echo "üß™ Skipping Rust fmt/clippy/tests for this push."
  echo "üîé Running lightweight shell syntax checks..."
  run_shell_syntax_checks "$changed_files"
  echo ""
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "‚úÖ Pre-push checks PASSED (docs/scripts-only mode)"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  exit 0
fi

# Extract crate names from commit scopes
detect_crates_from_scopes() {
  local commits_input="$1"
  local -a crates=()
  local invalid_scopes=0
  local scope_re='^[a-z]+\(([^)]+)\):'

  # Extract scope from "type(scope): message" format
  # scope can be: products/accounts/backend ‚Üí accounts-backend
  # or: products/core/engine ‚Üí engine
  # or: scripts/... ‚Üí (skip, not a crate)
  while IFS= read -r line; do
    # Match pattern: type(scope):
    if [[ $line =~ $scope_re ]]; then
      local -a raw_scopes=()
      local raw_scope
      IFS=',' read -r -a raw_scopes <<< "${BASH_REMATCH[1]}"

      for raw_scope in "${raw_scopes[@]}"; do
        local scope="${raw_scope#"${raw_scope%%[![:space:]]*}"}"
        scope="${scope%"${scope##*[![:space:]]}"}"
        [[ -z "$scope" ]] && continue

        local cargo_toml=""
        if [[ $scope =~ ^projects/libraries/([^/]+)$ ]]; then
          cargo_toml="projects/libraries/${BASH_REMATCH[1]}/Cargo.toml"
        elif [[ $scope =~ ^projects/products/([^/]+)(/(ui|backend))?$ ]]; then
          local product="${BASH_REMATCH[1]}"
          local component="${BASH_REMATCH[3]:-}"
          local -a matches=()
          local match
          while IFS= read -r match; do
            [[ -n "$match" ]] && matches+=("$match")
          done < <(find projects/products -type f -path "*/${product}/${component:+$component/}Cargo.toml")

          if [[ ${#matches[@]} -eq 1 ]]; then
            cargo_toml="${matches[0]}"
          elif [[ ${#matches[@]} -gt 1 ]]; then
            echo "‚ö†Ô∏è  Scope '$scope' matches multiple Cargo.toml files; falling back to workspace:"
            printf '   - %s\n' "${matches[@]}"
            invalid_scopes=$((invalid_scopes + 1))
            continue
          fi
        fi

        if [[ -n "$cargo_toml" ]]; then
          if [[ ! -f "$cargo_toml" ]]; then
            invalid_scopes=$((invalid_scopes + 1))
            continue
          fi

          local crate_name
          crate_name=$(sed -n 's/^name[[:space:]]*=[[:space:]]*"\([^"]*\)".*/\1/p' "$cargo_toml" | head -n1)
          if [[ -z "$crate_name" ]]; then
            invalid_scopes=$((invalid_scopes + 1))
            continue
          fi

          if [[ ! " ${crates[*]} " =~ " ${crate_name} " ]]; then
            crates+=("$crate_name")
          fi
        fi
      done
    fi
  done <<< "$commits_input"

  # If there were invalid scopes, return empty (force full workspace test)
  if [[ $invalid_scopes -gt 0 ]]; then
    return 1
  fi

  printf '%s\n' "${crates[@]+"${crates[@]}"}"
}

# Get affected crates from commit scopes
AFFECTED=$(detect_crates_from_scopes "$commits")
SCOPE_VALID=$?

LOCKED_ARGS=()
if [[ -f Cargo.lock ]]; then
  LOCKED_ARGS=(--locked)
fi

if [[ $SCOPE_VALID -ne 0 ]] || [[ -z "$AFFECTED" ]]; then
  echo "‚ö†Ô∏è  Invalid or missing crate scope(s) in commits - testing full workspace"
  echo "   (Use scopes like 'refactor(projects/libraries/security):' or 'fix(projects/products/accounts/backend):')"
  echo ""
  CLIPPY_ARGS=("${LOCKED_ARGS[@]}" --workspace --all-targets --all-features)
  TEST_ARGS=("${LOCKED_ARGS[@]}" --workspace --all-targets --all-features)
else
  echo "üéØ Crates from commit scopes:"
  echo "$AFFECTED" | sed 's/^/   - /'
  echo ""

  # Build clippy/test args for affected crates
  CLIPPY_ARGS=("${LOCKED_ARGS[@]}" --all-targets --all-features)
  TEST_ARGS=("${LOCKED_ARGS[@]}" --all-targets --all-features)
  while IFS= read -r crate; do
    [[ -z "$crate" ]] && continue
    CLIPPY_ARGS+=(-p "$crate")
    TEST_ARGS+=(-p "$crate")
  done <<< "$AFFECTED"
fi

# Track overall status
FAILED=0

# 1. Check formatting
echo "üìù Checking code formatting..."
if ! cargo fmt --all --check; then
  echo ""
  echo "‚ùå Code formatting check failed!"
  echo "   Run: cargo fmt --all"
  echo ""
  FAILED=1
else
  echo "‚úÖ Formatting OK"
  echo ""
fi

# 2. Run clippy on affected crates
echo "üîé Running clippy..."
if ! cargo clippy "${CLIPPY_ARGS[@]}" -- -D warnings; then
  echo ""
  echo "‚ùå Clippy found issues!"
  echo "   Run: cargo clippy ${CLIPPY_ARGS[*]} -- -D warnings"
  echo ""
  FAILED=1
else
  echo "‚úÖ Clippy OK"
  echo ""
fi

# 3. Run tests on affected crates
echo "üß™ Running tests..."
if ! cargo test "${TEST_ARGS[@]}"; then
  echo ""
  echo "‚ùå Tests failed!"
  echo "   Run: cargo test ${TEST_ARGS[*]}"
  echo ""
  FAILED=1
else
  echo "‚úÖ Tests OK"
  echo ""
fi

# Final result
if [[ $FAILED -eq 1 ]]; then
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "‚ùå Pre-push checks FAILED"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  echo "Please fix the issues before pushing."
  echo "Bypass (emergency only): SKIP_PRE_PUSH=1 git push"
  echo ""
  exit 1
fi

echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "‚úÖ All pre-push checks PASSED"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""

exit 0
