#!/usr/bin/env bash
# Git hook: pre-push
# Runs scope-aware formatting, linting, and tests before push
# Bypass: SKIP_PRE_PUSH=1 git push ...
set -euo pipefail

# Allow bypass for emergency situations
if [[ "${SKIP_PRE_PUSH:-}" == "1" ]]; then
  echo "âš ï¸  Pre-push checks skipped (SKIP_PRE_PUSH=1)"
  exit 0
fi

echo "ðŸ” Running pre-push checks..."
echo ""

# Get the root of the git repository
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT" || exit 1

# Get commit messages from commits being pushed
UPSTREAM_BRANCH="$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")"
if [[ -z "$UPSTREAM_BRANCH" ]]; then
  echo "âš ï¸  No upstream branch detected. Falling back to origin/dev for scope detection."
  UPSTREAM_BRANCH="origin/dev"
fi

commits=$(git log "$UPSTREAM_BRANCH"..HEAD --format=%B 2>/dev/null || true)

compute_changed_files() {
  local upstream="$1"
  local files=""

  # Standard case: upstream tracking branch exists.
  files=$(git diff --name-only "${upstream}"..HEAD 2>/dev/null || true)
  if [[ -n "$files" ]]; then
    printf '%s\n' "$files"
    return 0
  fi

  # First push / missing upstream locally: compare from merge-base with origin/dev.
  if git rev-parse --verify --quiet origin/dev >/dev/null; then
    local base
    base=$(git merge-base origin/dev HEAD 2>/dev/null || true)
    if [[ -n "$base" ]]; then
      files=$(git diff --name-only "${base}"..HEAD 2>/dev/null || true)
      if [[ -n "$files" ]]; then
        printf '%s\n' "$files"
        return 0
      fi
    fi
  fi

  # Final fallback: changed files in the latest commit only.
  files=$(git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null || true)
  printf '%s\n' "$files"
}

changed_files=$(compute_changed_files "$UPSTREAM_BRANCH")

is_docs_or_scripts_only_change() {
  local files="$1"
  local file

  [[ -z "$files" ]] && return 1

  while IFS= read -r file; do
    [[ -z "$file" ]] && continue
    # Intentionally treat workflow-only changes as non-Rust changes for pre-push.
    # Workflow logic is validated in CI/automation workflows and review.
    if [[ "$file" =~ \.md$ ]] || [[ "$file" == documentation/* ]] || [[ "$file" == .github/documentation/* ]] || [[ "$file" == .github/ISSUE_TEMPLATE/* ]] || [[ "$file" == .github/PULL_REQUEST_TEMPLATE/* ]] || [[ "$file" == scripts/* ]] || [[ "$file" == .github/workflows/* ]]; then
      continue
    fi
    return 1
  done <<< "$files"

  return 0
}

run_shell_syntax_checks() {
  local files="$1"
  local checked=0
  local file

  while IFS= read -r file; do
    [[ -z "$file" || ! -f "$file" ]] && continue

    local is_shell=false
    if [[ "$file" == *.sh ]]; then
      is_shell=true
    elif [[ -x "$file" ]]; then
      local shebang
      shebang=$(head -n1 "$file" 2>/dev/null || true)
      if [[ "$shebang" =~ ^#!.*(ba)?sh([[:space:]]|$) ]]; then
        is_shell=true
      fi
    fi

    if [[ "$is_shell" == true ]]; then
      echo "   - bash -n $file"
      bash -n "$file"
      checked=1
    fi
  done <<< "$files"

  if [[ $checked -eq 0 ]]; then
    echo "   (no shell scripts changed)"
  fi
}

if is_docs_or_scripts_only_change "$changed_files"; then
  echo "ðŸ“„ Docs/scripts-only changes detected."
  echo "ðŸ§ª Skipping Rust fmt/clippy/tests for this push."
  echo "ðŸ”Ž Running lightweight shell syntax checks..."
  run_shell_syntax_checks "$changed_files"
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "âœ… Pre-push checks PASSED (docs/scripts-only mode)"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  exit 0
fi

# Extract crate names from commit scopes
detect_crates_from_scopes() {
  local commits_input="$1"
  local -a crates=()
  local invalid_scopes=0
  local scope_re='^[a-z]+\(([^)]+)\):'

  # Extract scope from "type(scope): message" format
  # scope can be: products/accounts/backend â†’ accounts-backend
  # or: products/core/engine â†’ engine
  # or: scripts/... â†’ (skip, not a crate)
  while IFS= read -r line; do
    # Match pattern: type(scope):
    if [[ $line =~ $scope_re ]]; then
      local -a raw_scopes=()
      local raw_scope
      IFS=',' read -r -a raw_scopes <<< "${BASH_REMATCH[1]}"

      for raw_scope in "${raw_scopes[@]}"; do
        local scope="${raw_scope#"${raw_scope%%[![:space:]]*}"}"
        scope="${scope%"${scope##*[![:space:]]}"}"
        [[ -z "$scope" ]] && continue

        local cargo_toml=""
        if [[ $scope =~ ^projects/libraries/([^/]+)$ ]]; then
          cargo_toml="projects/libraries/${BASH_REMATCH[1]}/Cargo.toml"
        elif [[ $scope =~ ^projects/products/([^/]+)(/(ui|backend))?$ ]]; then
          local product="${BASH_REMATCH[1]}"
          local component="${BASH_REMATCH[3]:-}"
          local -a matches=()
          local match
          while IFS= read -r match; do
            [[ -n "$match" ]] && matches+=("$match")
          done < <(find projects/products -type f -path "*/${product}/${component:+$component/}Cargo.toml")

          if [[ ${#matches[@]} -eq 1 ]]; then
            cargo_toml="${matches[0]}"
          elif [[ ${#matches[@]} -gt 1 ]]; then
            echo "âš ï¸  Scope '$scope' matches multiple Cargo.toml files; falling back to workspace:"
            printf '   - %s\n' "${matches[@]}"
            invalid_scopes=$((invalid_scopes + 1))
            continue
          fi
        fi

        if [[ -n "$cargo_toml" ]]; then
          if [[ ! -f "$cargo_toml" ]]; then
            invalid_scopes=$((invalid_scopes + 1))
            continue
          fi

          local crate_name
          crate_name=$(sed -n 's/^name[[:space:]]*=[[:space:]]*"\([^"]*\)".*/\1/p' "$cargo_toml" | head -n1)
          if [[ -z "$crate_name" ]]; then
            invalid_scopes=$((invalid_scopes + 1))
            continue
          fi

          if [[ ! " ${crates[*]} " =~ " ${crate_name} " ]]; then
            crates+=("$crate_name")
          fi
        fi
      done
    fi
  done <<< "$commits_input"

  # If there were invalid scopes, return empty (force full workspace test)
  if [[ $invalid_scopes -gt 0 ]]; then
    return 1
  fi

  printf '%s\n' "${crates[@]+"${crates[@]}"}"
}

# Get affected crates from commit scopes
AFFECTED=$(detect_crates_from_scopes "$commits")
SCOPE_VALID=$?

LOCKED_ARGS=()
if [[ -f Cargo.lock ]]; then
  LOCKED_ARGS=(--locked)
fi

if [[ $SCOPE_VALID -ne 0 ]] || [[ -z "$AFFECTED" ]]; then
  echo "âš ï¸  Invalid or missing crate scope(s) in commits - testing full workspace"
  echo "   (Use scopes like 'refactor(projects/libraries/security):' or 'fix(projects/products/accounts/backend):')"
  echo ""
  CLIPPY_ARGS=("${LOCKED_ARGS[@]}" --workspace --all-targets --all-features)
  TEST_ARGS=("${LOCKED_ARGS[@]}" --workspace --all-targets --all-features)
else
  echo "ðŸŽ¯ Crates from commit scopes:"
  echo "$AFFECTED" | sed 's/^/   - /'
  echo ""

  # Build clippy/test args for affected crates
  CLIPPY_ARGS=("${LOCKED_ARGS[@]}" --all-targets --all-features)
  TEST_ARGS=("${LOCKED_ARGS[@]}" --all-targets --all-features)
  while IFS= read -r crate; do
    [[ -z "$crate" ]] && continue
    CLIPPY_ARGS+=(-p "$crate")
    TEST_ARGS+=(-p "$crate")
  done <<< "$AFFECTED"
fi

# Track overall status
FAILED=0

# 1. Check formatting
echo "ðŸ“ Checking code formatting..."
if ! cargo fmt --all --check; then
  echo ""
  echo "âŒ Code formatting check failed!"
  echo "   Run: cargo fmt --all"
  echo ""
  FAILED=1
else
  echo "âœ… Formatting OK"
  echo ""
fi

# 2. Run clippy on affected crates
echo "ðŸ”Ž Running clippy..."
if ! cargo clippy "${CLIPPY_ARGS[@]}" -- -D warnings; then
  echo ""
  echo "âŒ Clippy found issues!"
  echo "   Run: cargo clippy ${CLIPPY_ARGS[*]} -- -D warnings"
  echo ""
  FAILED=1
else
  echo "âœ… Clippy OK"
  echo ""
fi

# 3. Run tests on affected crates
echo "ðŸ§ª Running tests..."
if ! cargo test "${TEST_ARGS[@]}"; then
  echo ""
  echo "âŒ Tests failed!"
  echo "   Run: cargo test ${TEST_ARGS[*]}"
  echo ""
  FAILED=1
else
  echo "âœ… Tests OK"
  echo ""
fi

# Final result
if [[ $FAILED -eq 1 ]]; then
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "âŒ Pre-push checks FAILED"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  echo "Please fix the issues before pushing."
  echo "Bypass (emergency only): SKIP_PRE_PUSH=1 git push"
  echo ""
  exit 1
fi

echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… All pre-push checks PASSED"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

exit 0
