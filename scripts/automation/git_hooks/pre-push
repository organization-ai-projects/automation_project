#!/usr/bin/env bash
# Git hook: pre-push
# Runs scope-aware formatting, linting, and tests before push
# Bypass: SKIP_PRE_PUSH=1 git push ...
set -euo pipefail

# Allow bypass for emergency situations
if [[ "${SKIP_PRE_PUSH:-}" == "1" ]]; then
  echo "‚ö†Ô∏è  Pre-push checks skipped (SKIP_PRE_PUSH=1)"
  exit 0
fi

echo "üîç Running pre-push checks..."
echo ""

# Get the root of the git repository
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT" || exit 1

# Get commit messages from commits being pushed
UPSTREAM_BRANCH="$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")"
if [[ -z "$UPSTREAM_BRANCH" ]]; then
  echo "‚ö†Ô∏è  No upstream branch detected. Falling back to origin/dev for scope detection."
  UPSTREAM_BRANCH="origin/dev"
fi

commits=$(git log "$UPSTREAM_BRANCH"..HEAD --format=%B 2>/dev/null || true)

extract_closing_issue_refs_from_commits() {
  local commits_input="$1"
  echo "$commits_input" | awk '
    BEGIN { IGNORECASE = 1 }
    {
      line = $0
      while (match(line, /(closes|fixes|resolves)[[:space:]]+#[0-9]+/)) {
        ref = substr(line, RSTART, RLENGTH)
        if (match(ref, /#[0-9]+/)) {
          print substr(ref, RSTART + 1, RLENGTH - 1)
        }
        line = substr(line, RSTART + RLENGTH)
      }
    }
  ' | sort -u
}

issue_has_required_children_tasklist() {
  local issue_body="$1"
  echo "$issue_body" | awk '
    /-[[:space:]]*\[[xX ]\]/ {
      if (match($0, /#[0-9]+/)) {
        found = 1
      }
    }
    END { exit(found ? 0 : 1) }
  '
}

validate_parent_closure_footers() {
  local commits_input="$1"
  local refs
  refs=$(extract_closing_issue_refs_from_commits "$commits_input")
  [[ -z "$refs" ]] && return 0

  if ! command -v gh >/dev/null 2>&1; then
    echo "‚ùå Cannot validate closing footers on parent issues: 'gh' CLI is required."
    echo "   Install gh, or bypass in emergency: SKIP_PRE_PUSH=1 git push"
    return 1
  fi

  local repo_name
  repo_name="$(gh repo view --json nameWithOwner -q '.nameWithOwner' 2>/dev/null || true)"
  if [[ -z "$repo_name" ]]; then
    echo "‚ùå Cannot resolve GitHub repository for footer validation."
    echo "   Ensure gh auth/network is available, or bypass in emergency: SKIP_PRE_PUSH=1 git push"
    return 1
  fi

  local parent_refs=()
  local issue_number
  while IFS= read -r issue_number; do
    [[ -z "$issue_number" ]] && continue
    local issue_body
    issue_body="$(gh issue view "$issue_number" -R "$repo_name" --json body -q '.body' 2>/dev/null || true)"

    if [[ -z "$issue_body" ]]; then
      echo "‚ùå Unable to validate issue #$issue_number from closing footer."
      echo "   Ensure issue is readable and network is available, or bypass in emergency: SKIP_PRE_PUSH=1 git push"
      return 1
    fi

    if issue_has_required_children_tasklist "$issue_body"; then
      parent_refs+=("$issue_number")
    fi
  done <<< "$refs"

  if [[ ${#parent_refs[@]} -gt 0 ]]; then
    echo "‚ùå Closing footer targets parent issue(s):"
    printf '   - #%s\n' "${parent_refs[@]}"
    echo "   Attention: referenced issue is a parent. No direct closure is authorized via commit footer."
    echo "   Use child issues for Closes/Fixes/Resolves; use Related to/Part of for parent tracking."
    return 1
  fi
}

if ! validate_parent_closure_footers "$commits"; then
  exit 1
fi

compute_changed_files() {
  local upstream="$1"
  local files=""

  # Standard case: upstream tracking branch exists.
  files=$(git diff --name-only "${upstream}"..HEAD 2>/dev/null || true)
  if [[ -n "$files" ]]; then
    printf '%s\n' "$files"
    return 0
  fi

  # First push / missing upstream locally: compare from merge-base with origin/dev.
  if git rev-parse --verify --quiet origin/dev >/dev/null; then
    local base
    base=$(git merge-base origin/dev HEAD 2>/dev/null || true)
    if [[ -n "$base" ]]; then
      files=$(git diff --name-only "${base}"..HEAD 2>/dev/null || true)
      if [[ -n "$files" ]]; then
        printf '%s\n' "$files"
        return 0
      fi
    fi
  fi

  # Final fallback: changed files in the latest commit only.
  files=$(git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null || true)
  printf '%s\n' "$files"
}

changed_files=$(compute_changed_files "$UPSTREAM_BRANCH")

is_docs_or_scripts_only_change() {
  local files="$1"
  local file

  [[ -z "$files" ]] && return 1

  while IFS= read -r file; do
    [[ -z "$file" ]] && continue
    # Intentionally treat workflow-only changes as non-Rust changes for pre-push.
    # Workflow logic is validated in CI/automation workflows and review.
    if [[ "$file" =~ \.md$ ]] || [[ "$file" == documentation/* ]] || [[ "$file" == .github/documentation/* ]] || [[ "$file" == .github/ISSUE_TEMPLATE/* ]] || [[ "$file" == .github/PULL_REQUEST_TEMPLATE/* ]] || [[ "$file" == scripts/* ]] || [[ "$file" == .github/workflows/* ]]; then
      continue
    fi
    return 1
  done <<< "$files"

  return 0
}

run_shell_syntax_checks() {
  local files="$1"
  local checked=0
  local file

  while IFS= read -r file; do
    [[ -z "$file" || ! -f "$file" ]] && continue

    local is_shell=false
    if [[ "$file" == *.sh ]]; then
      is_shell=true
    elif [[ -x "$file" ]]; then
      local shebang
      shebang=$(head -n1 "$file" 2>/dev/null || true)
      if [[ "$shebang" =~ ^#!.*(ba)?sh([[:space:]]|$) ]]; then
        is_shell=true
      fi
    fi

    if [[ "$is_shell" == true ]]; then
      echo "   - bash -n $file"
      bash -n "$file"
      checked=1
    fi
  done <<< "$files"

  if [[ $checked -eq 0 ]]; then
    echo "   (no shell scripts changed)"
  fi
}

if is_docs_or_scripts_only_change "$changed_files"; then
  echo "üìÑ Docs/scripts-only changes detected."
  echo "üß™ Skipping Rust fmt/clippy/tests for this push."
  echo "üîé Running lightweight shell syntax checks..."
  run_shell_syntax_checks "$changed_files"
  echo ""
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "‚úÖ Pre-push checks PASSED (docs/scripts-only mode)"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  exit 0
fi

# Extract crate names from commit scopes
detect_crates_from_scopes() {
  local commits_input="$1"
  local -a crates=()
  local invalid_scopes=0
  local scope_re='^[a-z]+\(([^)]+)\):'

  # Extract scope from "type(scope): message" format
  # scope can be: products/accounts/backend ‚Üí accounts-backend
  # or: products/core/engine ‚Üí engine
  # or: scripts/... ‚Üí (skip, not a crate)
  while IFS= read -r line; do
    # Match pattern: type(scope):
    if [[ $line =~ $scope_re ]]; then
      local -a raw_scopes=()
      local raw_scope
      IFS=',' read -r -a raw_scopes <<< "${BASH_REMATCH[1]}"

      for raw_scope in "${raw_scopes[@]}"; do
        local scope="${raw_scope#"${raw_scope%%[![:space:]]*}"}"
        scope="${scope%"${scope##*[![:space:]]}"}"
        [[ -z "$scope" ]] && continue

        local cargo_toml=""
        if [[ $scope =~ ^projects/libraries/([^/]+)$ ]]; then
          cargo_toml="projects/libraries/${BASH_REMATCH[1]}/Cargo.toml"
        elif [[ $scope =~ ^projects/products/([^/]+)(/(ui|backend))?$ ]]; then
          local product="${BASH_REMATCH[1]}"
          local component="${BASH_REMATCH[3]:-}"
          local -a matches=()
          local match
          while IFS= read -r match; do
            [[ -n "$match" ]] && matches+=("$match")
          done < <(find projects/products -type f -path "*/${product}/${component:+$component/}Cargo.toml")

          if [[ ${#matches[@]} -eq 1 ]]; then
            cargo_toml="${matches[0]}"
          elif [[ ${#matches[@]} -gt 1 ]]; then
            echo "‚ö†Ô∏è  Scope '$scope' matches multiple Cargo.toml files; falling back to workspace:"
            printf '   - %s\n' "${matches[@]}"
            invalid_scopes=$((invalid_scopes + 1))
            continue
          fi
        fi

        if [[ -n "$cargo_toml" ]]; then
          if [[ ! -f "$cargo_toml" ]]; then
            invalid_scopes=$((invalid_scopes + 1))
            continue
          fi

          local crate_name
          crate_name=$(sed -n 's/^name[[:space:]]*=[[:space:]]*"\([^"]*\)".*/\1/p' "$cargo_toml" | head -n1)
          if [[ -z "$crate_name" ]]; then
            invalid_scopes=$((invalid_scopes + 1))
            continue
          fi

          if [[ ! " ${crates[*]} " =~ " ${crate_name} " ]]; then
            crates+=("$crate_name")
          fi
        fi
      done
    fi
  done <<< "$commits_input"

  # If there were invalid scopes, return empty (force full workspace test)
  if [[ $invalid_scopes -gt 0 ]]; then
    return 1
  fi

  printf '%s\n' "${crates[@]+"${crates[@]}"}"
}

# Get affected crates from commit scopes
AFFECTED=$(detect_crates_from_scopes "$commits")
SCOPE_VALID=$?

LOCKED_ARGS=()
if [[ -f Cargo.lock ]]; then
  LOCKED_ARGS=(--locked)
fi

if [[ $SCOPE_VALID -ne 0 ]] || [[ -z "$AFFECTED" ]]; then
  echo "‚ö†Ô∏è  Invalid or missing crate scope(s) in commits - testing full workspace"
  echo "   (Use scopes like 'refactor(projects/libraries/security):' or 'fix(projects/products/accounts/backend):')"
  echo ""
  CLIPPY_ARGS=("${LOCKED_ARGS[@]}" --workspace --all-targets --all-features)
  TEST_ARGS=("${LOCKED_ARGS[@]}" --workspace --all-targets --all-features)
else
  echo "üéØ Crates from commit scopes:"
  echo "$AFFECTED" | sed 's/^/   - /'
  echo ""

  # Build clippy/test args for affected crates
  CLIPPY_ARGS=("${LOCKED_ARGS[@]}" --all-targets --all-features)
  TEST_ARGS=("${LOCKED_ARGS[@]}" --all-targets --all-features)
  while IFS= read -r crate; do
    [[ -z "$crate" ]] && continue
    CLIPPY_ARGS+=(-p "$crate")
    TEST_ARGS+=(-p "$crate")
  done <<< "$AFFECTED"
fi

# Track overall status
FAILED=0

# 1. Check formatting
echo "üìù Checking code formatting..."
if ! cargo fmt --all --check; then
  echo ""
  echo "‚ùå Code formatting check failed!"
  echo "   Run: cargo fmt --all"
  echo ""
  FAILED=1
else
  echo "‚úÖ Formatting OK"
  echo ""
fi

# 2. Run clippy on affected crates
echo "üîé Running clippy..."
if ! cargo clippy "${CLIPPY_ARGS[@]}" -- -D warnings; then
  echo ""
  echo "‚ùå Clippy found issues!"
  echo "   Run: cargo clippy ${CLIPPY_ARGS[*]} -- -D warnings"
  echo ""
  FAILED=1
else
  echo "‚úÖ Clippy OK"
  echo ""
fi

# 3. Run tests on affected crates
echo "üß™ Running tests..."
if ! cargo test "${TEST_ARGS[@]}"; then
  echo ""
  echo "‚ùå Tests failed!"
  echo "   Run: cargo test ${TEST_ARGS[*]}"
  echo ""
  FAILED=1
else
  echo "‚úÖ Tests OK"
  echo ""
fi

# Final result
if [[ $FAILED -eq 1 ]]; then
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "‚ùå Pre-push checks FAILED"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo ""
  echo "Please fix the issues before pushing."
  echo "Bypass (emergency only): SKIP_PRE_PUSH=1 git push"
  echo ""
  exit 1
fi

echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo "‚úÖ All pre-push checks PASSED"
echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
echo ""

exit 0
