#!/usr/bin/env bash
# Git hook: pre-push
# Runs scope-aware formatting, linting, and tests before push
# Bypass: SKIP_PRE_PUSH=1 git push ...
set -euo pipefail

# Allow bypass for emergency situations
if [[ "${SKIP_PRE_PUSH:-}" == "1" ]]; then
  echo "âš ï¸  Pre-push checks skipped (SKIP_PRE_PUSH=1)"
  exit 0
fi

echo "ðŸ” Running pre-push checks..."
echo ""

# Get the root of the git repository
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT" || exit 1

# Get commit messages from commits being pushed
UPSTREAM_BRANCH="$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")"
if [[ -z "$UPSTREAM_BRANCH" ]]; then
  echo "âš ï¸  No upstream branch detected. Falling back to origin/dev for scope detection."
  UPSTREAM_BRANCH="origin/dev"
fi

commits=$(git log "$UPSTREAM_BRANCH"..HEAD --format=%B 2>/dev/null)
changed_files=$(git diff --name-only "$UPSTREAM_BRANCH"..HEAD 2>/dev/null || true)

is_docs_or_scripts_only_change() {
  local files="$1"
  local file

  [[ -z "$files" ]] && return 1

  while IFS= read -r file; do
    [[ -z "$file" ]] && continue
    # Intentionally treat workflow-only changes as non-Rust changes for pre-push.
    # Workflow logic is validated in CI/automation workflows and review.
    if [[ "$file" =~ \.md$ ]] || [[ "$file" == documentation/* ]] || [[ "$file" == .github/documentation/* ]] || [[ "$file" == .github/ISSUE_TEMPLATE/* ]] || [[ "$file" == .github/PULL_REQUEST_TEMPLATE/* ]] || [[ "$file" == scripts/* ]] || [[ "$file" == .github/workflows/* ]]; then
      continue
    fi
    return 1
  done <<< "$files"

  return 0
}

run_shell_syntax_checks() {
  local files="$1"
  local checked=0
  local file

  while IFS= read -r file; do
    [[ -z "$file" ]] && continue
    if [[ "$file" == *.sh ]] || [[ "$file" == scripts/automation/git_hooks/* ]]; then
      if [[ -f "$file" ]]; then
        echo "   - bash -n $file"
        bash -n "$file"
        checked=1
      fi
    fi
  done <<< "$files"

  if [[ $checked -eq 0 ]]; then
    echo "   (no shell scripts changed)"
  fi
}

if is_docs_or_scripts_only_change "$changed_files"; then
  echo "ðŸ“„ Docs/scripts-only changes detected."
  echo "ðŸ§ª Skipping Rust fmt/clippy/tests for this push."
  echo "ðŸ”Ž Running lightweight shell syntax checks..."
  run_shell_syntax_checks "$changed_files"
  echo ""
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "âœ… Pre-push checks PASSED (docs/scripts-only mode)"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  exit 0
fi

# Extract crate names from commit scopes
detect_crates_from_scopes() {
  local crates=()
  local invalid_scopes=0
  local scope_re='^[a-z]+\(([^)]+)\):'

  # Extract scope from "type(scope): message" format
  # scope can be: products/accounts/backend â†’ accounts-backend
  # or: products/core/engine â†’ engine
  # or: scripts/... â†’ (skip, not a crate)
  while IFS= read -r line; do
    # Match pattern: type(scope):
    if [[ $line =~ $scope_re ]]; then
      local scope="${BASH_REMATCH[1]}"

      local cargo_toml=""
      if [[ $scope =~ ^projects/libraries/([^/]+)$ ]]; then
        cargo_toml="projects/libraries/${BASH_REMATCH[1]}/Cargo.toml"
      elif [[ $scope =~ ^projects/products/([^/]+)(/(ui|backend))?$ ]]; then
        local product="${BASH_REMATCH[1]}"
        local component="${BASH_REMATCH[3]:-}"
        local matches=()
        while IFS= read -r match; do
          [[ -n "$match" ]] && matches+=("$match")
        done < <(find projects/products -type f -path "*/${product}/${component:+$component/}Cargo.toml")

        if [[ ${#matches[@]} -eq 1 ]]; then
          cargo_toml="${matches[0]}"
        elif [[ ${#matches[@]} -gt 1 ]]; then
          invalid_scopes=$((invalid_scopes + 1))
          continue
        fi
      fi

      if [[ -n "$cargo_toml" ]]; then
        if [[ ! -f "$cargo_toml" ]]; then
          invalid_scopes=$((invalid_scopes + 1))
          continue
        fi

        local crate_name
        crate_name=$(sed -n 's/^name[[:space:]]*=[[:space:]]*"\([^"]*\)".*/\1/p' "$cargo_toml" | head -n1)
        if [[ -z "$crate_name" ]]; then
          invalid_scopes=$((invalid_scopes + 1))
          continue
        fi

        if [[ ! " ${crates[@]} " =~ " ${crate_name} " ]]; then
          crates+=("$crate_name")
        fi
      fi
    fi
  done <<< "$commits"

  # If there were invalid scopes, return empty (force full workspace test)
  if [[ $invalid_scopes -gt 0 ]]; then
    return 1
  fi

  printf '%s\n' "${crates[@]}"
}

# Get affected crates from commit scopes
AFFECTED=$(detect_crates_from_scopes)
SCOPE_VALID=$?

if [[ $SCOPE_VALID -ne 0 ]] || [[ -z "$AFFECTED" ]]; then
  echo "âš ï¸  Invalid or missing crate scope(s) in commits - testing full workspace"
  echo "   (Use scopes like 'refactor(projects/libraries/security):' or 'fix(projects/products/accounts/backend):')"
  echo ""
  CLIPPY_ARGS="--all-targets --all-features"
  TEST_ARGS="--workspace"
else
  echo "ðŸŽ¯ Crates from commit scopes:"
  echo "$AFFECTED" | sed 's/^/   - /'
  echo ""

  # Build clippy/test args for affected crates
  CLIPPY_ARGS=""
  TEST_ARGS=""
  while IFS= read -r crate; do
    [[ -z "$crate" ]] && continue
    CLIPPY_ARGS+=" -p $crate"
    TEST_ARGS+=" -p $crate"
  done <<< "$AFFECTED"
fi

# Track overall status
FAILED=0

# 1. Check formatting
echo "ðŸ“ Checking code formatting..."
if ! cargo fmt --all --check; then
  echo ""
  echo "âŒ Code formatting check failed!"
  echo "   Run: cargo fmt --all"
  echo ""
  FAILED=1
else
  echo "âœ… Formatting OK"
  echo ""
fi

# 2. Run clippy on affected crates
echo "ðŸ”Ž Running clippy..."
# shellcheck disable=SC2086
if ! cargo clippy $CLIPPY_ARGS -- -D warnings; then
  echo ""
  echo "âŒ Clippy found issues!"
  echo "   Run: cargo clippy $CLIPPY_ARGS -- -D warnings"
  echo ""
  FAILED=1
else
  echo "âœ… Clippy OK"
  echo ""
fi

# 3. Run tests on affected crates
echo "ðŸ§ª Running tests..."
# shellcheck disable=SC2086
if ! cargo test $TEST_ARGS; then
  echo ""
  echo "âŒ Tests failed!"
  echo "   Run: cargo test $TEST_ARGS"
  echo ""
  FAILED=1
else
  echo "âœ… Tests OK"
  echo ""
fi

# Final result
if [[ $FAILED -eq 1 ]]; then
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "âŒ Pre-push checks FAILED"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo ""
  echo "Please fix the issues before pushing."
  echo "Bypass (emergency only): SKIP_PRE_PUSH=1 git push"
  echo ""
  exit 1
fi

echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo "âœ… All pre-push checks PASSED"
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
echo ""

exit 0
