#!/usr/bin/env bash
# Git hook: pre-commit
# Formats code before commit
# Bypass: SKIP_PRE_COMMIT=1 git commit ...
set -euo pipefail

# Allow bypass for emergency situations
if [[ "${SKIP_PRE_COMMIT:-}" == "1" ]]; then
  echo "‚ö†Ô∏è  Pre-commit checks skipped (SKIP_PRE_COMMIT=1)"
  exit 0
fi

echo "üìù Running pre-commit checks..."
echo ""

# Get the root of the git repository
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT" || exit 1
# shellcheck source=scripts/common_lib/automation/scope_resolver.sh
source "$REPO_ROOT/scripts/common_lib/automation/scope_resolver.sh"
# shellcheck source=scripts/common_lib/automation/file_types.sh
source "$REPO_ROOT/scripts/common_lib/automation/file_types.sh"
# shellcheck source=scripts/automation/git_hooks/lib/markdownlint_policy.sh
source "$REPO_ROOT/scripts/automation/git_hooks/lib/markdownlint_policy.sh"
PUSH_POLICY_FILE="$REPO_ROOT/scripts/automation/git_hooks/lib/push_policy.sh"
if [[ -f "$PUSH_POLICY_FILE" ]]; then
  # shellcheck source=scripts/automation/git_hooks/lib/push_policy.sh
  source "$PUSH_POLICY_FILE"
fi

# Protect integration branches from direct commits.
# Use ALLOW_PROTECTED_BRANCH_COMMIT=1 only for exceptional maintenance work.
CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
if [[ "${ALLOW_PROTECTED_BRANCH_COMMIT:-}" != "1" ]] \
  && [[ "$CURRENT_BRANCH" == "dev" || "$CURRENT_BRANCH" == "main" ]]; then
  echo "‚ùå Direct commits on protected branch '$CURRENT_BRANCH' are blocked."
  echo "   Create a feature/fix/docs branch, then open a PR."
  echo "   Temporary bypass (exception only): ALLOW_PROTECTED_BRANCH_COMMIT=1 git commit ..."
  exit 1
fi

# Early safety net: catch assignment-policy violations already present in local push range.
if declare -F push_policy_validate_part_of_only_push >/dev/null 2>&1; then
  UPSTREAM_BRANCH="$(push_policy_resolve_upstream_branch)"
  if declare -F push_policy_refresh_upstream_branch >/dev/null 2>&1; then
    push_policy_refresh_upstream_branch "$UPSTREAM_BRANCH"
  fi
  PUSH_COMMITS="$(push_policy_collect_push_commits "$UPSTREAM_BRANCH")"
  if ! push_policy_validate_part_of_only_push "$PUSH_COMMITS"; then
    echo ""
    echo "‚ùå Assignment policy check failed (early pre-commit guard)."
    exit 1
  fi
fi

# Get affected crates
STAGED_CHANGED_FILES="$(git diff --cached --name-only --diff-filter=ACMRU)"
AFFECTED="$(collect_crates_from_files "$STAGED_CHANGED_FILES")"
if [[ -z "$AFFECTED" ]]; then
  echo "üéØ No Rust crates detected, checking all files"
else
  echo "üéØ Affected crates:"
  echo "$AFFECTED" | sed 's/^/   - /'
  echo ""
fi

# 1. Check orchestrator script permissions on staged orchestrator files only.
echo "üîí Checking orchestrator script permissions..."
PERMISSION_ERRORS=0
STAGED_ORCHESTRATOR_FILES="$(printf '%s\n' "$STAGED_CHANGED_FILES" | grep -E '^scripts/versioning/file_versioning/orchestrators/(read|execute)/.*\.sh$' || true)"

while IFS= read -r script; do
  [[ -z "$script" ]] && continue
  if [[ "$script" == scripts/versioning/file_versioning/orchestrators/read/* ]]; then
    if [[ -x "$script" ]]; then
      echo "   ‚ùå $script should NOT be executable (use chmod 644)"
      PERMISSION_ERRORS=$((PERMISSION_ERRORS + 1))
    fi
    continue
  fi
  if [[ "$script" == scripts/versioning/file_versioning/orchestrators/execute/* ]]; then
    if [[ ! -x "$script" ]]; then
      echo "   ‚ùå $script should be executable (use chmod 755)"
      PERMISSION_ERRORS=$((PERMISSION_ERRORS + 1))
    fi
  fi
done <<< "$STAGED_ORCHESTRATOR_FILES"

if [[ $PERMISSION_ERRORS -gt 0 ]]; then
  echo ""
  echo "‚ùå Script permission errors detected!"
  echo "   Convention: read/ scripts = 644, execute/ scripts = 755"
  exit 1
fi

# 2. Run markdown lint for staged markdown files.
MARKDOWN_LINT_FILES="$(printf '%s\n' "$STAGED_CHANGED_FILES" | grep -E '\.md$' || true)"
if [[ -n "$MARKDOWN_LINT_FILES" ]]; then
  echo "üìù Auto-fixing markdown files..."
  mapfile -t MARKDOWN_FILES_ARR < <(printf '%s\n' "$MARKDOWN_LINT_FILES" | sed '/^$/d')
  if [[ ${#MARKDOWN_FILES_ARR[@]} -gt 0 ]]; then
    if ! markdownlint_policy_run_fix_and_checks "$(printf '%s\n' "${MARKDOWN_FILES_ARR[@]}")"; then
      echo ""
      echo "‚ùå Markdown lint failed on staged markdown files."
      exit 1
    fi
  fi
else
  echo "üìù Skipping markdown lint (no staged markdown files)"
fi

# 3. Run shell syntax checks for staged shell files.
echo "üîé Checking shell syntax..."
SHELL_ERRORS=0
while IFS= read -r staged_file; do
  [[ -z "$staged_file" ]] && continue
  if is_shell_file "$staged_file"; then
    if ! bash -n "$staged_file"; then
      echo "   ‚ùå Shell syntax error: $staged_file"
      SHELL_ERRORS=$((SHELL_ERRORS + 1))
    fi
  fi
done <<< "$STAGED_CHANGED_FILES"

if [[ $SHELL_ERRORS -gt 0 ]]; then
  echo ""
  echo "‚ùå Shell syntax checks failed!"
  exit 1
fi

# 4. Format Rust files only when Rust sources are staged.
if printf '%s\n' "$STAGED_CHANGED_FILES" | grep -qE '\.rs$'; then
  echo "‚ú® Formatting code..."
  if ! cargo fmt --all; then
    echo ""
    echo "‚ùå Formatting failed!"
    exit 1
  fi
else
  echo "‚ú® Skipping Rust formatting (no staged Rust files)"
fi

# Re-add only files that were already staged (avoid scooping unrelated changes)
mapfile -t STAGED_FILES < <(git diff --cached --name-only --diff-filter=ACMRU)
if [[ ${#STAGED_FILES[@]} -gt 0 ]]; then
  git add -- "${STAGED_FILES[@]}"
fi

echo "‚úÖ Pre-commit checks passed"
echo ""

exit 0
