#!/usr/bin/env bash
# Git hook: pre-commit
# Formats code before commit
# Bypass: SKIP_PRE_COMMIT=1 git commit ...
set -euo pipefail

# Allow bypass for emergency situations
if [[ "${SKIP_PRE_COMMIT:-}" == "1" ]]; then
  echo "‚ö†Ô∏è  Pre-commit checks skipped (SKIP_PRE_COMMIT=1)"
  exit 0
fi

echo "üìù Running pre-commit checks..."
echo ""

# Get the root of the git repository
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT" || exit 1
# shellcheck source=scripts/common_lib/automation/scope_resolver.sh
source "$REPO_ROOT/scripts/common_lib/automation/scope_resolver.sh"
# shellcheck source=scripts/common_lib/automation/file_types.sh
source "$REPO_ROOT/scripts/common_lib/automation/file_types.sh"

# Protect integration branches from direct commits.
# Use ALLOW_PROTECTED_BRANCH_COMMIT=1 only for exceptional maintenance work.
CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
if [[ "${ALLOW_PROTECTED_BRANCH_COMMIT:-}" != "1" ]] \
  && [[ "$CURRENT_BRANCH" == "dev" || "$CURRENT_BRANCH" == "main" ]]; then
  echo "‚ùå Direct commits on protected branch '$CURRENT_BRANCH' are blocked."
  echo "   Create a feature/fix/docs branch, then open a PR."
  echo "   Temporary bypass (exception only): ALLOW_PROTECTED_BRANCH_COMMIT=1 git commit ..."
  exit 1
fi

# Get affected crates
STAGED_CHANGED_FILES="$(git diff --cached --name-only --diff-filter=ACMRU)"
AFFECTED="$(collect_crates_from_files "$STAGED_CHANGED_FILES")"
if [[ -z "$AFFECTED" ]]; then
  echo "üéØ No Rust crates detected, checking all files"
else
  echo "üéØ Affected crates:"
  echo "$AFFECTED" | sed 's/^/   - /'
  echo ""
fi

# 1. Check orchestrator script permissions on staged orchestrator files only.
echo "üîí Checking orchestrator script permissions..."
PERMISSION_ERRORS=0
STAGED_ORCHESTRATOR_FILES="$(printf '%s\n' "$STAGED_CHANGED_FILES" | grep -E '^scripts/versioning/file_versioning/orchestrators/(read|execute)/.*\.sh$' || true)"

while IFS= read -r script; do
  [[ -z "$script" ]] && continue
  if [[ "$script" == scripts/versioning/file_versioning/orchestrators/read/* ]]; then
    if [[ -x "$script" ]]; then
      echo "   ‚ùå $script should NOT be executable (use chmod 644)"
      PERMISSION_ERRORS=$((PERMISSION_ERRORS + 1))
    fi
    continue
  fi
  if [[ "$script" == scripts/versioning/file_versioning/orchestrators/execute/* ]]; then
    if [[ ! -x "$script" ]]; then
      echo "   ‚ùå $script should be executable (use chmod 755)"
      PERMISSION_ERRORS=$((PERMISSION_ERRORS + 1))
    fi
  fi
done <<< "$STAGED_ORCHESTRATOR_FILES"

if [[ $PERMISSION_ERRORS -gt 0 ]]; then
  echo ""
  echo "‚ùå Script permission errors detected!"
  echo "   Convention: read/ scripts = 644, execute/ scripts = 755"
  exit 1
fi

# 2. Run markdown lint for staged markdown files.
MARKDOWN_LINT_FILES="$(printf '%s\n' "$STAGED_CHANGED_FILES" | grep -E '\.md$' || true)"
if [[ -n "$MARKDOWN_LINT_FILES" ]]; then
  echo "üìù Linting markdown files..."
  if ! command -v pnpm >/dev/null 2>&1; then
    echo ""
    echo "‚ùå Markdown lint requires pnpm when markdown files are staged."
    echo "   Install: corepack enable && corepack prepare pnpm@9 --activate"
    exit 1
  fi
  if [[ ! -f "$REPO_ROOT/package.json" ]]; then
    echo ""
    echo "‚ùå Markdown lint requires package.json at repository root."
    exit 1
  fi
  if [[ ! -f "$REPO_ROOT/node_modules/.bin/markdownlint-cli2" ]]; then
    echo ""
    echo "‚ùå Markdown lint dependencies are missing."
    echo "   Run: pnpm install --frozen-lockfile"
    exit 1
  fi

  mapfile -t MARKDOWN_FILES_ARR < <(printf '%s\n' "$MARKDOWN_LINT_FILES" | sed '/^$/d')
  if [[ ${#MARKDOWN_FILES_ARR[@]} -gt 0 ]]; then
    if ! pnpm run -s lint-md-files -- "${MARKDOWN_FILES_ARR[@]}"; then
      echo ""
      echo "‚ùå Markdown lint failed on staged markdown files."
      echo "   Run: pnpm run lint-md-files -- ${MARKDOWN_FILES_ARR[*]}"
      exit 1
    fi
  fi
else
  echo "üìù Skipping markdown lint (no staged markdown files)"
fi

# 3. Run shell syntax checks for staged shell files.
echo "üîé Checking shell syntax..."
SHELL_ERRORS=0
while IFS= read -r staged_file; do
  [[ -z "$staged_file" ]] && continue
  if is_shell_file "$staged_file"; then
    if ! bash -n "$staged_file"; then
      echo "   ‚ùå Shell syntax error: $staged_file"
      SHELL_ERRORS=$((SHELL_ERRORS + 1))
    fi
  fi
done <<< "$STAGED_CHANGED_FILES"

if [[ $SHELL_ERRORS -gt 0 ]]; then
  echo ""
  echo "‚ùå Shell syntax checks failed!"
  exit 1
fi

# 4. Format Rust files only when Rust sources are staged.
if printf '%s\n' "$STAGED_CHANGED_FILES" | grep -qE '\.rs$'; then
  echo "‚ú® Formatting code..."
  if ! cargo fmt --all; then
    echo ""
    echo "‚ùå Formatting failed!"
    exit 1
  fi
else
  echo "‚ú® Skipping Rust formatting (no staged Rust files)"
fi

# Re-add only files that were already staged (avoid scooping unrelated changes)
mapfile -t STAGED_FILES < <(git diff --cached --name-only --diff-filter=ACMRU)
if [[ ${#STAGED_FILES[@]} -gt 0 ]]; then
  git add -- "${STAGED_FILES[@]}"
fi

echo "‚úÖ Pre-commit checks passed"
echo ""

exit 0
